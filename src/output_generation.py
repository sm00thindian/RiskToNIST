import json
import pandas as pd
import plotly.express as px
import logging
from datetime import datetime

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def generate_json(control_to_risk, nist_controls, cve_details, output_file):
    if not control_to_risk:
        logger.warning("No controls mapped to CVEs. JSON output will be empty.")
    data = []
    for control, info in control_to_risk.items():
        try:
            cve_list = [
                {
                    'cveID': cve,
                    'vulnerabilityName': cve_details[cve]['name'],
                    'shortDescription': cve_details[cve]['description'],
                    'dueDate': cve_details[cve]['dueDate']
                } for cve in info['cves']
            ]
            control_info = nist_controls.get(control.upper(), {'family': 'Unknown', 'title': 'Unknown'})
            data.append({
                'control_id': control,
                'family': control_info['family'],
                'description': control_info['title'],
                'total_risk': info['total_risk'],
                'cves': cve_list
            })
        except KeyError as e:
            logger.warning(f"Skipping control {control} due to missing data: {e}")
            continue
    data.sort(key=lambda x: x['total_risk'], reverse=True)
    with open(output_file, 'w') as f:
        json.dump(data, f, indent=2)

def generate_csv(control_to_risk, nist_controls, cve_details, output_file):
    if not control_to_risk:
        logger.warning("No controls mapped to CVEs. CSV output will be empty.")
        pd.DataFrame().to_csv(output_file, index=False)
        return
    
    records = []
    for control, info in control_to_risk.items():
        if 'total_risk' not in info or 'cves' not in info:
            logger.error(f"Invalid control_to_risk entry for {control}: {info}")
            continue
        try:
            control_info = nist_controls.get(control.upper(), {'family': 'Unknown', 'title': 'Unknown'})
            for cve in info['cves']:
                records.append({
                    'control_id': control,
                    'family': control_info['family'],
                    'control_description': control_info['title'],
                    'total_risk': info['total_risk'],
                    'cveID': cve,
                    'vulnerabilityName': cve_details[cve]['name'],
                    'shortDescription': cve_details[cve]['description'],
                    'dueDate': cve_details[cve]['dueDate']
                })
        except KeyError as e:
            logger.warning(f"Skipping control {control} due to missing data: {e}")
            continue
    
    if not records:
        logger.warning("No valid records generated for CSV output.")
        pd.DataFrame().to_csv(output_file, index=False)
        return
    
    df = pd.DataFrame(records)
    try:
        df = df.sort_values(by="total_risk", ascending=False)
        df.to_csv(output_file, index=False)
    except KeyError as e:
        logger.error(f"Failed to sort CSV DataFrame: {e}")
        df.to_csv(output_file, index=False)

def generate_html(control_to_risk, nist_controls, cve_details, total_cves, output_file):
    # Sort controls by total_risk in descending order
    sorted_controls = sorted(
        control_to_risk.items(),
        key=lambda x: x[1]['total_risk'],
        reverse=True
    )

    # Start HTML content
    html_content = """

    
        
        
            Cybersecurity Risk Assessment Report

            Generated by RiskToNIST on {generation_date}

            Total CVEs Analyzed: {total_cves}

        

        
        
            About This Report

            
                This report identifies cybersecurity risks in our systems by analyzing known vulnerabilities (CVEs) and mapping them to NIST SP 800-53 security controls. It highlights which controls are most at risk, helping us prioritize actions to strengthen our security posture. Each control is assigned a risk score based on the vulnerabilities associated with it, and controls are sorted from highest to lowest risk for clear decision-making.
            

        

        
        
            How We Calculate Risk

            
                The risk score for each NIST control reflects the total risk from all vulnerabilities (CVEs) linked to that control. Each CVE is assigned a risk score based on its severity, exploitability, and potential impact, as defined in our data mappings. We sum these scores for all CVEs associated with a control to get the total risk. Higher scores indicate controls that need urgent attention due to significant or numerous vulnerabilities.
            

        

        
        
            Risk-Based Control Assessment

            
                Row	Control ID	Family	Control Description	Total Risk	Associated CVEs


    """.format(
        generation_date=datetime.now().strftime("%B %d, %Y"),
        total_cves=total_cves
    )

    # Add table rows for each control with row count
    for idx, (control_id, info) in enumerate(sorted_controls, 1):
        control_info = nist_controls.get(control_id.upper(), {'family': 'Unknown', 'title': 'No description available'})
        family = control_info.get('family', 'Unknown')
        description = control_info.get('title', 'No description available')
        total_risk = info['total_risk']
        cve_count = len(info['cves'])

        html_content += f"""
                        {idx}	{control_id.upper()}	{family}	{description}	{total_risk:.1f}	
                                {cve_count} CVE{'s' if cve_count != 1 else ''}
                            


        """

    html_content += """
                    
                
            

            
                Note: Controls are sorted by total risk, with the highest-risk controls listed first. Click the CVE count to view detailed vulnerability information for each control. Use the Show/Hide buttons to expand or collapse CVE details.
            

        

        
        
            Detailed CVE Information

    """

    # Add detailed CVE sections for each control
    for control_id, info in sorted_controls:
        if not info['cves']:
            continue
        html_content += f"""
            
                CVEs for Control {control_id.upper()}

                
                    Show CVEs
                
                
                    CVE ID	Vulnerability Name	Description	Due Date


        """
        # Sort CVEs by dueDate in descending order (newest first)
        sorted_cves = sorted(
            info['cves'],
            key=lambda cve: (
                datetime.strptime(cve_details[cve]['dueDate'], '%Y-%m-%d')
                if cve_details[cve]['dueDate'] != 'N/A'
                else datetime.min
            ),
            reverse=True
        )
        for cve in sorted_cves:
            cve_info = cve_details.get(cve, {'name': 'Unknown', 'description': 'No description available', 'dueDate': 'N/A'})
            cve_link = f"https://nvd.nist.gov/vuln/detail/{cve}"
            html_content += f"""
                            <a href='{cve_link}' target='_blank'>{cve}</a>	{cve_info['name']}	{cve_info['description']}	{cve_info['dueDate']}


            """
        html_content += """
                        
                    
                

            

        """

    # Add JavaScript for toggling CVE sections
    html_content += """
        

        
        

        
        
            Generated by RiskToNIST | Â© {year} All rights reserved.

        
    


    """.format(year=datetime.now().year)

    # Write to output file
    with open(output_file, 'w') as f:
        f.write(html_content)
